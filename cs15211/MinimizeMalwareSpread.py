__source__ = 'https://leetcode.com/problems/minimize-malware-spread/'
# Time:  O(N^2)
# Space: O(N)
#
# Union-Find
#
# Description: Leetcode # 924. Minimize Malware Spread
#
# In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
#
# Some nodes initial are initially infected by malware.
# Whenever two nodes are directly connected and at least one of those two nodes is infected by malware,
# both nodes will be infected by malware.
# This spread of malware will continue until no more nodes can be infected in this manner.
#
# Suppose M(initial) is the final number of nodes infected with malware in the entire network,
# after the spread of malware stops.
#
# We will remove one node from the initial list.  Return the node that if removed, would minimize M(initial).
# If multiple nodes could be removed to minimize M(initial), return such a node with the smallest index.
#
# Note that if a node was removed from the initial list of infected nodes,
# it may still be infected later as a result of the malware spread.
#
# Example 1:
#
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# Example 2:
#
# Input: graph = [[1,0,0],[0,1,0],[0,0,1]], initial = [0,2]
# Output: 0
# Example 3:
#
# Input: graph = [[1,1,1],[1,1,1],[1,1,1]], initial = [1,2]
# Output: 1
#
#
# Note:
#
# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] = 1
# 1 <= initial.length < graph.length
# 0 <= initial[i] < graph.length
#
import unittest
import collections
# DFS
# 152ms 88.07%
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        # 1. Color each component.
        # colors[node] = the color of this node.

        N = len(graph)
        colors = {}
        c = 0

        def dfs(node, color):
            colors[node] = color
            for nei, adj in enumerate(graph[node]):
                if adj and nei not in colors:
                    dfs(nei, color)

        for node in xrange(N):
            if node not in colors:
                dfs(node, c)
                c += 1

        # 2. Size of each color.
        # size[color] = number of occurrences of this color.
        size = collections.Counter(colors.values())

        # 3. Find unique colors.
        color_count = collections.Counter()
        for node in initial:
            color_count[colors[node]] += 1

        # 4. Answer
        ans = float('inf')
        for x in initial:
            c = colors[x]
            if color_count[c] == 1:
                if ans == float('inf'):
                    ans = x
                elif size[c] > size[colors[ans]]:
                    ans = x
                elif size[c] == size[colors[ans]] and x < ans:
                    ans = x

        return ans if ans < float('inf') else min(initial)

# union find
# 220ms 53.91%
class DSU:
    def __init__(self, N):
        self.p = range(N)
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]


class SolutionUF(object):
    def minMalwareSpread(self, graph, initial):
        dsu = DSU(len(graph))

        for j, row in enumerate(graph):
            for i in xrange(j):
                if row[i]:
                    dsu.union(i, j)

        count = collections.Counter(dsu.find(u) for u in initial)
        ans = (-1, min(initial))
        for node in initial:
            root = dsu.find(node)
            if count[root] == 1:  # unique color
                if dsu.size(root) > ans[0]:
                    ans = dsu.size(root), node
                elif dsu.size(root) == ans[0] and node < ans[1]:
                    ans = dsu.size(root), node

        return ans[1]


# BFS?
# 84ms 100%
class Solution3(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        initialSet = set(initial)
        maxNode = 0
        maxN = -1
        n = len(graph)
        for i, node in enumerate(sorted(initial)):
            l = [node, ]
            visited = set([node,])
            result = 0
            while l:
                s = l.pop(0)
                result += 1
                for i in xrange(n):
                    if graph[s][i] == 1:
                        if i in visited:
                            continue
                        if i in initialSet:
                            result = 0
                            break
                        visited.add(i)
                        l.append(i)
                if result == 0:
                    break
            if result > maxN:
                maxN = result
                maxNode = node
        return maxNode

class TestMethods(unittest.TestCase):
    def test_Local(self):
        self.assertEqual(1, 1)


if __name__ == '__main__':
    unittest.main()

Java = '''
# Thought: https://leetcode.com/problems/minimize-malware-spread/solution/

Approach 1: Depth First Search
# Algorithm
#
# This algorithm has a few parts:
#
# 1. Coloring each component: For each node, if it isn't yet colored,
# use a depth-first search to traverse its component,
# coloring that component with a new color.
#
# 2. Size of each color: Count the number of occurrences of each color.
#
# 3. Find unique colors: Look at the colors of nodes in initial to see which nodes have unique colors.
#
# 4. Choose answer: For each node with a unique color, find the size of that color.
# The largest size is selected, with ties broken by lowest node number.
# If there is no node with a unique color, the answer is min(initial).

Complexity Analysis
Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
Space Complexity: O(N)
# 9ms 98.62%

class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        // 1. Color each component.
        // colors[node] = the color of this node.
        int N = graph.length;
        int[] colors = new int[N];
        Arrays.fill(colors, -1);
        int C = 0;

        for (int node = 0; node < N; ++node){
            if (colors[node] == -1) dfs(graph, colors, node, C++);
        }

        // 2. Size of each color.
        int[] size = new int[C];
        for (int color : colors) size[color]++;

        // 3. Find unique colors.
        int[] colorCount = new int[C];
        for(int node: initial) {
            colorCount[colors[node]]++;
        }

        // 4. Answer
        int ans = Integer.MAX_VALUE;
        for (int node: initial) {
            int c = colors[node];
            if (colorCount[c] == 1) {
                if (ans == Integer.MAX_VALUE) {
                    ans = node;
                } else if (size[c] > size[colors[ans]]) {
                    ans = node;
                } else if (size[c] == size[colors[ans]] && node < ans){
                    ans = node;
                }
            }
        }
        if (ans == Integer.MAX_VALUE) {
            for (int node : initial) ans = Math.min(ans, node);
        }
        return ans;
    }

    private void dfs(int[][] graph, int[] colors, int node, int color) {
        colors[node] = color;
        for (int nei = 0; nei < graph.length; ++nei) {
            if (graph[node][nei] == 1 && colors[nei] == -1) dfs(graph, colors, nei, color);
        }
    }
}

# 6ms 100%
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Arrays.sort(initial);
        HashSet<Integer> set = new HashSet<>();
        for (int i: initial) set.add(i);
        int res = -1;
        int num = Integer.MIN_VALUE;
        for (int i : initial) {
            int tmp = DFS(graph, set, i);
            if (tmp > num) {
                res = i;
                num = tmp;
            }
        }
        return res;

    }

    private int DFS(int[][] graph, HashSet<Integer> set, int i) {
        HashSet<Integer> visited = new HashSet<>();
        visited.add(i);
        int col = graph[0].length;
        Stack<Integer> stack = new Stack<>();
        stack.push(i);
        int num = 0;
        while (!stack.isEmpty()) {
            int node = stack.pop();
            num++;
            for (int c = 0; c < col; c++) {
                if (graph[node][c] == 1) {
                    if (set.contains(c) && c != i) return 0;
                    if (!visited.contains(c)) {
                        stack.push(c);
                        visited.add(c);
                    }
                }
            }
        }
        return num;
    }
}
# BFS
# 150ms 15.57%
class Solution {
    private int spread(int [][] graph, Set<Integer> infected){
        Set<Integer> bad = new HashSet<>(infected);
        Queue<Integer> bfs= new LinkedList<>();
        for(Integer initialInfected:infected){
            bfs.add(initialInfected);
        }
        while(!bfs.isEmpty()){
            Integer next = bfs.remove();
            for(int j=0; j<graph[next].length;++j){
                if(graph[next][j]==1&& !bad.contains(j)){
                    bad.add(j);
                    bfs.add(j);
                }
            }
        }
        //return how many total were infected after spreading
        return bad.size();
    }
    public int minMalwareSpread(int[][] graph, int[] initial) {
        Set<Integer> infected = new HashSet<>();
        for(int initialInfected: initial){
            infected.add(initialInfected);
        }
        int min = Integer.MAX_VALUE;
        int ans = 0;
        for(int ignore = 0; ignore<initial.length;++ignore){
            int ignoreNumb = initial[ignore];
            infected.remove(ignoreNumb);
            int amount = spread(graph,infected);
            if(amount<min ||(amount==min&& initial[ignore]<ans)){
                ans=initial[ignore];
                min=amount;
            }
            infected.add(ignoreNumb);
        }
        return ans;
    }
}


Approach 2: Union-Find
Complexity Analysis
Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
Space Complexity: O(N)
# 14ms 82.64%

class Solution {
    class UF{
        int[] p;
        int[] cnt;

        public UF(int n) {
            p = new int[n];
            cnt = new int[n];
            for (int i = 0; i < n; i++) {
                p[i] = i;
                cnt[i] = 1;
            }
        }

        public int find(int i) {
            if (p[i] != i) p[i] = find(p[i]);
            return p[i];
        }

        public void union(int i, int j) {
            int x = find(i), y = find(j);
            if (x == y) return;
            p[x] = y;
            cnt[y] += cnt[x];
        }

    }

    public int minMalwareSpread(int[][] graph, int[] initial) {
        int n = graph.length;
        UF uf = new UF(n);
        for ( int i = 0; i < n; i++ ){
            for (int j = i + 1; j < n; j++) {
                if (graph[i][j] == 1) uf.union(i, j);
            }
        }

        Map<Integer, Integer> map = new HashMap<>();
        for (int i : initial) {
            int r = uf.find(i);
            map.put(r, map.getOrDefault(i, 0) + 1);
        }

        Arrays.sort( initial );
        int ans = -1, max = -1;
        for (int i : initial) {
            int r = uf.find(i);
            int saved = map.get(r) == 1 ? uf.cnt[r] : 0;
            if (saved > max) {
                ans = i;
                max = saved;

            }
        }
        return ans;
    }
}
'''
