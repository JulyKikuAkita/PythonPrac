__source__ = 'https://leetcode.com/problems/minimize-malware-spread-ii/'
# Time:  O(N^2)
# Space: O(N)
#
# Description: Leetcode # 928. Minimize Malware Spread II
#
# (This problem is the same as Minimize Malware Spread, with the differences bolded.)
#
# In a network of nodes, each node i is directly connected to another node j if and only if graph[i][j] = 1.
#
# Some nodes initial are initially infected by malware.
# Whenever two nodes are directly connected and at least one of those two nodes is infected by malware,
# both nodes will be infected by malware.
# This spread of malware will continue until no more nodes can be infected in this manner.
#
# Suppose M(initial) is the final number of nodes infected with malware in the entire network,
# after the spread of malware stops.
#
# We will remove one node from the initial list,
# completely removing it and any connections from this node to any other node.
# Return the node that if removed, would minimize M(initial).
# If multiple nodes could be removed to minimize M(initial),
# return such a node with the smallest index.
#
# Example 1:
#
# Input: graph = [[1,1,0],[1,1,0],[0,0,1]], initial = [0,1]
# Output: 0
# Example 2:
#
# Input: graph = [[1,1,0],[1,1,1],[0,1,1]], initial = [0,1]
# Output: 1
# Example 3:
#
# Input: graph = [[1,1,0,0],[1,1,1,0],[0,1,1,1],[0,0,1,1]], initial = [0,1]
# Output: 1
#
# Note:
#
# 1 < graph.length = graph[0].length <= 300
# 0 <= graph[i][j] == graph[j][i] <= 1
# graph[i][i] = 1
# 1 <= initial.length < graph.length
# 0 <= initial[i] < graph.length
#
import unittest
import collections
# 572ms 25.39%
class Solution(object):
    def minMalwareSpread(self, graph, initial):
        """
        :type graph: List[List[int]]
        :type initial: List[int]
        :rtype: int
        """
        N = len(graph)
        clean = set(range(N)) - set(initial)
        def dfs(u, seen):
            for v, adj in enumerate(graph[u]):
                if adj and v in clean and v not in seen:
                    seen.add(v)
                    dfs(v, seen)

        # For each node u in initial, dfs to find
        # 'seen': all nodes not in initial that it can reach.
        infected_by = {v: [] for v in clean}
        for u in initial:
            seen = set()
            dfs(u, seen)

            # For each node v that was seen, u infects v.
            for v in seen:
                infected_by[v].append(u)

        # For each node u in initial, for every v not in initial
        # that is uniquely infected by u, add 1 to the contribution for u.
        contribution = collections.Counter()
        for v, neighbors in infected_by.iteritems():
            if len(neighbors) == 1:
                contribution[neighbors[0]] += 1

        # Take the best answer.
        best = (-1, min(initial))
        for u, score in contribution.iteritems():
            if score > best[0] or score == best[0] and u < best[1]:
                best = score, u
        return best[1]

class DSU:
    def __init__(self, N):
        self.p = range(N)
        self.sz = [1] * N

    def find(self, x):
        if self.p[x] != x:
            self.p[x] = self.find(self.p[x])
        return self.p[x]

    def union(self, x, y):
        xr = self.find(x)
        yr = self.find(y)
        self.p[xr] = yr
        self.sz[yr] += self.sz[xr]

    def size(self, x):
        return self.sz[self.find(x)]

# 132ms 92.86%
class Solution2(object):
    def minMalwareSpread(self, graph, initial):
        N = len(graph)
        initial_set = set(initial)
        clean = [x for x in range(N) if x not in initial_set]

        # clean[u] == 1 if its a node in the graph not in initial.
        dsu = DSU(N)
        for u in clean:
            for v in clean:
                if graph[u][v]:
                    dsu.union(u, v)

        # dsu now represents the components of the graph without
        # any nodes from initial.  Let's call this graph G.
        count = collections.Counter()
        node_to_compo = {}
        for u in initial:
            components = set()
            for v in clean:
                if graph[u][v]:
                    components.add(dsu.find(v))
            node_to_compo[u] = components

            for c in components:
                count[c] += 1

        # For each node u in initial, nodeToCompo.get(u)
        # now has every component from G that u neighbors.

        best = (-1, None) # score, node
        for u, components in node_to_compo.iteritems():
            score = 0
            for c in components:
                if count[c] == 1: #uniquely infected
                    score += dsu.size(c)
            if score > best[0] or score == best[0] and u < best[1]:
                best = (score, u)
        return best[1]

class TestMethods(unittest.TestCase):
    def test_Local(self):
        self.assertEqual(1, 1)

if __name__ == '__main__':
    unittest.main()

Java = '''
# Thought: https://leetcode.com/problems/minimize-malware-spread-ii/solution/
#
Approach 1: Depth First Search
Complexity Analysis
Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
Space Complexity: O(N) 

# 107ms 22.82%
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        int[] clean = new int[N];
        Arrays.fill(clean, 1);
        for (int x: initial)
            clean[x] = 0;

        // For each node u in initial, dfs to find
        // 'seen': all nodes not in initial that it can reach.
        ArrayList<Integer>[] infectedBy = new ArrayList[N];
        for (int i = 0; i < N; ++i)
            infectedBy[i] = new ArrayList();

        for (int u: initial) {
            Set<Integer> seen = new HashSet();
            dfs(graph, clean, u, seen);
            for (int v: seen)
                infectedBy[v].add(u);
        }

        // For each node u in initial, for every v not in initial
        // that is uniquely infected by u, add 1 to the contribution for u.
        int[] contribution = new int[N];
        for (int v = 0; v < N; ++v)
            if (infectedBy[v].size() == 1)
                contribution[infectedBy[v].get(0)]++;

        // Take the best answer.
        Arrays.sort(initial);
        int ans = initial[0], ansSize = -1;
        for (int u: initial) {
            int score = contribution[u];
            if (score > ansSize || score == ansSize && u < ans) {
                ans = u;
                ansSize = score;
            }
        }
        return ans;
    }

    public void dfs(int[][] graph, int[] clean, int u, Set<Integer> seen) {
        for (int v = 0; v < graph.length; ++v)
            if (graph[u][v] == 1 && clean[v] == 1 && !seen.contains(v)) {
                seen.add(v);
                dfs(graph, clean, v, seen);
            }
    }
}

# https://leetcode.com/problems/minimize-malware-spread-ii/discuss/187715/C%2B%2B
Approach 2: Union-Find
Complexity Analysis
Time Complexity: O(N^2), where N is the length of graph, as the graph is given in adjacent matrix form.
Space Complexity: O(N)

# 10ms 89.60%
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int N = graph.length;
        DSU dsu = new DSU(N);

        // clean[u] == 1 if its a node in the graph not in initial.
        int[] clean = new int[N];
        Arrays.fill(clean, 1);
        for (int x: initial) clean[x] = 0;

        for (int u = 0; u < N; ++u) if (clean[u] == 1)
            for (int v = 0; v < N; ++v) if (clean[v] == 1)
                if (graph[u][v] == 1)
                    dsu.union(u, v);

        // dsu now represents the components of the graph without
        // any nodes from initial.  Let's call this graph G.
        int[] count = new int[N];
        Map<Integer, Set<Integer>> nodeToCompo = new HashMap();
        for (int u: initial) {
            Set<Integer> components = new HashSet();
            for (int v = 0; v < N; ++v) if (clean[v] == 1) {
                if (graph[u][v] == 1)
                    components.add(dsu.find(v));
            }

            nodeToCompo.put(u, components);
            for (int c: components)
                count[c]++;
        }

        // For each node u in initial, nodeToCompo.get(u)
        // now has every component from G that u neighbors.

        int ans = -1, ansSize = -1;
        for (int u: nodeToCompo.keySet()) {
            Set<Integer> components = nodeToCompo.get(u);
            int score = 0;
            for (int c: components)
                if (count[c] == 1) // uniquely infected
                    score += dsu.size(c);

            if (score > ansSize || score == ansSize && u < ans) {
                ansSize = score;
                ans = u;
            }
        }

        return ans;
    }
}


class DSU {
    int[] p, sz;

    DSU(int N) {
        p = new int[N];
        for (int x = 0; x < N; ++x)
            p[x] = x;

        sz = new int[N];
        Arrays.fill(sz, 1);
    }

    public int find(int x) {
        if (p[x] != x)
            p[x] = find(p[x]);
        return p[x];
    }

    public void union(int x, int y) {
        int xr = find(x);
        int yr = find(y);
        p[xr] = yr;
        sz[yr] += sz[xr];
    }

    public int size(int x) {
        return sz[find(x)];
    }
}

# DFS
# 6ms 98.66%
class Solution {
    public int minMalwareSpread(int[][] graph, int[] initial) {
        int idx = -1;
        int maxNum = -1;
        Arrays.sort(initial);
        Set<Integer> set = new HashSet(); // initial -> num of pure nodes only connected to this initial
        for (int i : initial) set.add(i);
        
        for (int i : initial) {
            boolean[] visited = new boolean[graph.length];
            visited[i] = true;
            int saved = 1;
            for (int j = 0; j < graph[0].length; j++) {
                if(i == j || graph[i][j] == 0 || visited[j]) continue;
                int virus = dfs(j , graph, visited, set);
                if (virus >= 0) saved += virus;
            }
            if (saved > maxNum) {
                idx = i;
                maxNum = saved;
            }
        }
        return idx;
    }
    
    private int dfs(int node, int[][] graph, boolean[] visited, Set<Integer> set) {
        visited[node] = true;
        if (set.contains(node)) return -1; //encountered other initial nodes
        int res = 1; //-1 means no answer, >= 0 means node saved
        for (int i = 0; i < graph[0].length; i++) {
            if (i == node || graph[node][i] == 0 || visited[i]) continue;
            int tmp = dfs(i, graph, visited, set);
            if (tmp == -1) {
                set.add(node);
                return tmp;
            }
            res += tmp;
        }
        return res;
    }
}

# https://leetcode.com/problems/minimize-malware-spread-ii/discuss/184645/Straightforward-DFS-Java-6-ms

'''
